<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Snake-Game</title>

    <!-- Mobile-friendly viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <!-- SEO / sharing -->
    <meta name="description"
        content="A modern Nokia-style Snake game with levels, big food, high scores, touch controls, and theme switcher." />

    <!-- Browser UI color on mobile -->
    <meta name="theme-color" content="#020617" />

    <style>
        body {
            background: #020617;
            color: #fff;
            font-family: "Comic Sans MS", system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* Outer wrapper: game + mobile controls */
        #outer {
            position: relative;
            display: flex;
            flex-direction: column; /* default: stacked */
            align-items: center;
            gap: 12px;
            transform-origin: center center;
        }

        /* Layout behavior:
           - Mobile portrait: game on top, controls below (easier thumb reach)
           - Mobile landscape: side-by-side
           - Desktop: default stacked, but scaling keeps it nice
        */
        @media (max-width: 900px) and (orientation: portrait) {
            #outer {
                flex-direction: column;
                align-items: center;
            }
        }

        @media (max-width: 900px) and (orientation: landscape) {
            #outer {
                flex-direction: row;
                align-items: center;
            }
        }

        #wrapper {
            position: relative;
        }

        #game-container {
            position: relative;
            border: 2px solid #1f2937;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.6);
            background: #000;
            width: 640px;
            height: 520px;
            border-radius: 18px;
            overflow: hidden;
        }

        #top-panel {
            position: absolute;
            left: 0;
            top: 0;
            width: 640px;
            height: 60px;
            background: linear-gradient(90deg, #020617ee, #111827ee);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            box-sizing: border-box;
            font-size: 14px;
            gap: 6px;
            border-bottom: 1px solid #1f2937;
        }

        #top-left,
        #top-center,
        #top-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #timer-bar-bg {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 18px;
            width: 300px;
            height: 25px;
            background: #111827;
            border: 2px solid #f9fafb;
            box-sizing: border-box;
            display: none;
            border-radius: 999px;
            overflow: hidden;
        }

        #timer-bar-fill {
            width: 100%;
            height: 100%;
        }

        #canvas {
            display: block;
            background: #000;
        }

        #overlay {
            position: absolute;
            left: 0;
            top: 0;
            width: 640px;
            height: 520px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, #020617dd, #020617f5);
            color: #fff;
            flex-direction: column;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .btn {
            margin-top: 10px;
            padding: 10px 20px;
            border: none;
            border-radius: 14px;
            font-size: 16px;
            cursor: pointer;
            min-width: 160px;
            background: linear-gradient(135deg, #22c55e, #0ea5e9);
            color: #f9fafb;
            box-shadow: 0 10px 20px rgba(15, 118, 110, 0.4);
            transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 25px rgba(34, 197, 94, 0.45);
            filter: brightness(1.05);
        }

        .btn:active {
            transform: translateY(1px);
            box-shadow: 0 6px 15px rgba(15, 118, 110, 0.3);
        }

        /* Card-style top buttons */
        .top-btn {
            padding: 6px 10px;
            font-size: 12px;
            margin: 0;
            min-width: 70px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            background: radial-gradient(circle at 0 0, #38bdf8, #4f46e5);
            color: #e5e7eb;
            box-shadow: 0 6px 12px rgba(37, 99, 235, 0.5);
            transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
        }

        .top-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 9px 18px rgba(59, 130, 246, 0.6);
            filter: brightness(1.05);
        }

        .top-btn:active {
            transform: translateY(1px);
            box-shadow: 0 4px 10px rgba(37, 99, 235, 0.4);
        }

        #theme-indicator {
            font-size: 11px;
            opacity: 0.85;
        }

        #level-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #info-text {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
        }

        /* Touch controls for mobile: card-style pad */
        #touch-controls {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 14px;
            border-radius: 18px;
            background: radial-gradient(circle at top, #0f172acc, #020617f2);
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.8);
            gap: 6px;
        }

        #touch-controls-title {
            font-size: 13px;
            opacity: 0.85;
            margin-bottom: 2px;
        }

        #touch-controls-row {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .touch-btn {
            width: 52px;
            height: 52px;
            border-radius: 16px;
            border: none;
            background: linear-gradient(135deg, #22d3ee, #6366f1);
            color: #e5e7eb;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 20px rgba(59, 130, 246, 0.6);
            transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
        }

        .touch-btn:hover {
            filter: brightness(1.05);
        }

        .touch-btn:active {
            transform: translateY(1px);
            box-shadow: 0 5px 12px rgba(37, 99, 235, 0.5);
        }

        /* Show and enlarge touch controls on small screens */
        @media (max-width: 900px) {
            #touch-controls {
                display: flex;
                margin-top: 8px;
            }

            .touch-btn {
                width: 68px;
                height: 68px;
                border-radius: 20px;
                font-size: 24px;
            }

            #touch-controls-row {
                gap: 26px;
                margin-top: 8px;
            }
        }

        /* Footer with greeting only – fixed at bottom */
        #footer {
            position: fixed;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            opacity: 0.85;
            z-index: 5;
            /* above background, below modals */
        }

        #footer-text {
            white-space: nowrap;
        }

        /* About / Help modal shared styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.75);
            z-index: 9999;
        }

        .modal-card {
            width: min(90vw, 420px);
            background: radial-gradient(circle at top, #0b1120, #020617);
            border-radius: 18px;
            border: 1px solid #1f2937;
            padding: 18px 20px;
            box-shadow: 0 16px 40px rgba(15, 23, 42, 0.9);
        }

        .modal-card h3 {
            margin: 0 0 6px;
            font-size: 18px;
        }

        .modal-card p {
            margin: 4px 0;
            font-size: 13px;
            line-height: 1.5;
            opacity: 0.9;
        }

        .modal-card ul {
            margin: 8px 0 4px 20px;
            font-size: 13px;
            opacity: 0.9;
        }

        .modal-close {
            margin-top: 10px;
            padding: 6px 14px;
            border-radius: 999px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, #22c55e, #0ea5e9);
            color: #f9fafb;
            font-size: 13px;
            box-shadow: 0 6px 14px rgba(22, 163, 74, 0.6);
        }

        .modal-close:hover {
            filter: brightness(1.05);
        }
    </style>
</head>

<body>
    <div id="outer">
        <div id="wrapper">
            <div id="game-container">
                <canvas id="canvas" width="640" height="520"></canvas>

                <div id="top-panel">
                    <div id="top-left">
                        <span id="score-text">Score: 0</span>
                        <span id="level-text">Level: -</span>
                        <span id="best-text">Best: 0</span>
                    </div>
                    <div id="top-center">
                        <span id="theme-indicator">Theme: Nokia</span>
                    </div>
                    <div id="top-right">
                        <button class="top-btn" id="btn-about">About</button>
                        <button class="top-btn" id="btn-help">Help</button>
                        <button class="top-btn" id="btn-theme">Theme</button>
                        <button class="top-btn" id="btn-pause">Pause</button>
                        <button class="top-btn" id="btn-exit">Exit</button>
                    </div>
                </div>

                <div id="timer-bar-bg">
                    <div id="timer-bar-fill"></div>
                </div>

                <div id="overlay">
                    <h2 id="overlay-title">Welcome to Nokia Snake</h2>
                    <p id="overlay-subtitle">Select a level to start:</p>

                    <div id="level-buttons">
                        <button class="btn" data-level="Easy">Easy</button>
                        <button class="btn" data-level="Medium">Medium</button>
                        <button class="btn" data-level="Hard">Hard</button>
                    </div>

                    <p id="info-text">
                        Or press 1 (Easy), 2 (Medium), 3 (Hard)<br>
                        Use Arrow keys or W/A/S/D to move.
                    </p>

                    <!-- On game over, only this button stays -->
                    <button class="btn" id="btn-play-again" style="display:none;">Play Again</button>
                </div>
            </div>
        </div>

        <!-- Touch control "card" for mobile -->
        <div id="touch-controls">
            <div id="touch-controls-title">Controls</div>
            <button class="touch-btn" id="btn-up">▲</button>
            <div id="touch-controls-row">
                <button class="touch-btn" id="btn-left">◀</button>
                <button class="touch-btn" id="btn-down">▼</button>
                <button class="touch-btn" id="btn-right">▶</button>
            </div>
        </div>
    </div>

    <!-- Footer: separate, always below everything -->
    <div id="footer">
        <span id="footer-text">Made with ♥ by </RajCode-xs1dd></span>
    </div>

    <!-- About modal -->
    <div id="about-modal" class="modal-backdrop">
        <div id="about-card" class="modal-card">
            <h3>About Nokia Snake JS</h3>
            <p>A modern remake of the classic Nokia Snake, built with pure HTML, CSS, and JavaScript.</p>
            <p>Features:</p>
            <ul>
                <li>Three difficulty levels (Easy / Medium / Hard)</li>
                <li>Big food with a dynamic timer bar</li>
                <li>High score saved as “Snake Master”</li>
                <li>Mobile-friendly layout with on-screen controls</li>
                <li>Theme switch: Classic Nokia & Neon Cyber</li>
            </ul>
            <button id="about-close" class="modal-close">Close</button>
        </div>
    </div>

    <!-- Help modal -->
    <div id="help-modal" class="modal-backdrop">
        <div id="help-card" class="modal-card">
            <h3>How to Play</h3>
            <p><strong>Goal:</strong> Control the snake, eat food, grow longer, and beat the high score without hitting
                yourself.</p>
            <p><strong>Controls:</strong></p>
            <ul>
                <li>Keyboard: Arrow keys or W / A / S / D</li>
                <li>Mobile: Use the on-screen arrow buttons</li>
                <li>P or Pause button: Toggle pause / resume</li>
            </ul>
            <p><strong>Food & Scoring:</strong></p>
            <ul>
                <li>Red food: Normal food that increases score and length.</li>
                <li>Yellow big food: Appears sometimes with a shrinking timer bar.</li>
                <li>Eat big food quickly to earn more score & extra growth.</li>
            </ul>
            <p><strong>Tips:</strong></p>
            <ul>
                <li>Avoid running into your own body.</li>
                <li>Use Easy mode to learn, then try Medium / Hard.</li>
                <li>Watch the timer bar to time your big food rush.</li>
            </ul>
            <button id="help-close" class="modal-close">Close</button>
        </div>
    </div>

    <script>
        const WIDTH = 640;
        const HEIGHT = 520;
        const TOP_PANEL_HEIGHT = 60;
        const BLOCK_SIZE = 32;

        // Playable area: ensure bottom row visible and aligned
        const PLAY_HEIGHT_BLOCKS = Math.floor((HEIGHT - TOP_PANEL_HEIGHT) / BLOCK_SIZE);
        const PLAY_HEIGHT = PLAY_HEIGHT_BLOCKS * BLOCK_SIZE;
        const PLAY_BOTTOM_Y = TOP_PANEL_HEIGHT + PLAY_HEIGHT - BLOCK_SIZE;

        // Food visuals
        const SMALL_FOOD_RADIUS = BLOCK_SIZE * 0.35;
        const BIG_FOOD_RADIUS = BLOCK_SIZE * 0.8;

        // Slower snake speeds: Easy < Medium < Hard
        const SNAKE_SPEEDS = { Easy: 5, Medium: 8, Hard: 11 };

        const LEVEL_SCORE = { Easy: 1, Medium: 4, Hard: 7 };
        // Max possible big food scores if eaten instantly
        const BIG_FOOD_SCORE = { Easy: 5, Medium: 10, Hard: 15 };
        // Min score even if eaten very late
        const BIG_FOOD_MIN_SCORE = { Easy: 2, Medium: 3, Hard: 4 };

        const BIG_FOOD_DURATION = { Easy: 8, Medium: 6, Hard: 4 };

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const outer = document.getElementById("outer");

        const scoreText = document.getElementById("score-text");
        const levelText = document.getElementById("level-text");
        const bestText = document.getElementById("best-text");

        const overlay = document.getElementById("overlay");
        const overlayTitle = document.getElementById("overlay-title");
        const overlaySubtitle = document.getElementById("overlay-subtitle");
        const infoText = document.getElementById("info-text");
        const levelButtonsContainer = document.getElementById("level-buttons");
        const levelButtons = document.querySelectorAll("#level-buttons .btn");

        const btnPlayAgain = document.getElementById("btn-play-again");
        const btnPause = document.getElementById("btn-pause");
        const btnExit = document.getElementById("btn-exit");
        const btnTheme = document.getElementById("btn-theme");
        const btnAbout = document.getElementById("btn-about");
        const btnHelp = document.getElementById("btn-help");
        const themeIndicator = document.getElementById("theme-indicator");

        const timerBarBg = document.getElementById("timer-bar-bg");
        const timerBarFill = document.getElementById("timer-bar-fill");

        const btnUp = document.getElementById("btn-up");
        const btnDown = document.getElementById("btn-down");
        const btnLeft = document.getElementById("btn-left");
        const btnRight = document.getElementById("btn-right");

        const aboutModal = document.getElementById("about-modal");
        const helpModal = document.getElementById("help-modal");
        const aboutClose = document.getElementById("about-close");
        const helpClose = document.getElementById("help-close");

        let snake = [];
        let dx = BLOCK_SIZE;
        let dy = 0;

        let smallFood = null;
        let bigFood = null;
        let bigFoodStart = 0;
        let bigFoodDuration = 0;
        let foodCounter = 0;

        let score = 0;
        let level = null;
        let gameOver = false;
        let gameStarted = false;
        let paused = false;
        let loopId = null;

        // Theme system
        let theme = "nokia"; // "nokia" or "neon"
        let bgGradient = null;

        function updateTheme() {
            if (theme === "nokia") {
                bgGradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
                bgGradient.addColorStop(0, "#020617");
                bgGradient.addColorStop(1, "#022c22");
                themeIndicator.textContent = "Theme: Nokia";
            } else {
                bgGradient = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
                bgGradient.addColorStop(0, "#020617");
                bgGradient.addColorStop(0.5, "#4c1d95");
                bgGradient.addColorStop(1, "#0f172a");
                themeIndicator.textContent = "Theme: Neon";
            }
        }
        updateTheme();

        btnTheme.addEventListener("click", () => {
            theme = (theme === "nokia") ? "neon" : "nokia";
            updateTheme();
        });

        // High score
        let highScore = 0;
        const HS_KEY = "snakeHighScore";

        function loadHighScore() {
            const saved = localStorage.getItem(HS_KEY);
            highScore = saved ? parseInt(saved, 10) || 0 : 0;
            bestText.textContent = "Best: " + highScore;
        }

        function updateHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem(HS_KEY, String(highScore));
            }
            bestText.textContent = "Best: " + highScore;
        }

        loadHighScore();

        // Scale whole UI (game + controls) to fit screen
        function applyScale() {
            outer.style.transform = "scale(1)";
            const rect = outer.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;
            const scale = Math.min(
                window.innerWidth / w,
                (window.innerHeight - 30) / h    // leave some space for footer
            );
            outer.style.transform = `scale(${scale})`;
        }
        window.addEventListener("resize", applyScale);
        applyScale();

        function showLevelSelectScreen() {
            overlay.style.display = "flex";
            overlayTitle.textContent = "Welcome to Nokia Snake";
            overlaySubtitle.textContent = "Select a level to start:";
            infoText.style.display = "block";

            levelButtonsContainer.style.display = "flex";
            btnPlayAgain.style.display = "none";

            timerBarBg.style.display = "none";

            paused = false;
            btnPause.textContent = "Pause";
            gameStarted = false;
            gameOver = false;

            if (loopId) clearInterval(loopId);
        }

        function resetGame(selectedLevel) {
            level = selectedLevel;
            score = 0;
            dx = BLOCK_SIZE;
            dy = 0;
            gameOver = false;
            gameStarted = true;
            paused = false;
            foodCounter = 0;
            bigFood = null;
            bigFoodStart = 0;
            bigFoodDuration = BIG_FOOD_DURATION[level];

            const startY = TOP_PANEL_HEIGHT + 3 * BLOCK_SIZE;
            const startXCenter = Math.round((WIDTH / 2) / BLOCK_SIZE) * BLOCK_SIZE;
            snake = [
                [startXCenter - 2 * BLOCK_SIZE, startY],
                [startXCenter - 1 * BLOCK_SIZE, startY],
                [startXCenter, startY]
            ];

            smallFood = generateFood();
            scoreText.textContent = "Score: " + score;
            levelText.textContent = "Level: " + level;
            updateHighScore();

            overlay.style.display = "none";
            timerBarBg.style.display = "none";

            if (loopId) clearInterval(loopId);
            const fps = SNAKE_SPEEDS[level];
            const interval = 1000 / fps;
            loopId = setInterval(gameLoop, interval);
        }

        function generateFood() {
            while (true) {
                const xBlocks = WIDTH / BLOCK_SIZE;
                const x = Math.floor(Math.random() * xBlocks) * BLOCK_SIZE;

                const yBlocks = PLAY_HEIGHT_BLOCKS;
                const y = TOP_PANEL_HEIGHT + Math.floor(Math.random() * yBlocks) * BLOCK_SIZE;

                if (!snake.some(seg => seg[0] === x && seg[1] === y)) {
                    return [x, y];
                }
            }
        }

        function inSameCell(ax, ay, cell) {
            if (!cell) return false;
            const cx = Math.round(ax / BLOCK_SIZE);
            const cy = Math.round(ay / BLOCK_SIZE);
            const fx = Math.round(cell[0] / BLOCK_SIZE);
            const fy = Math.round(cell[1] / BLOCK_SIZE);
            return cx === fx && cy === fy;
        }

        function roundedRect(ctx, x, y, w, h, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
            ctx.fill();
        }

        function drawSnake() {
            if (!snake.length) return;

            // Soft glow for the whole snake
            ctx.save();
            ctx.shadowBlur = 9;
            ctx.shadowColor = (theme === "nokia")
                ? "rgba(52,211,153,0.85)"
                : "rgba(129,140,248,0.9)";

            for (let i = 0; i < snake.length; i++) {
                const [x, y] = snake[i];

                // Very small margin so blocks are very close (almost full cell)
                const margin = 1;
                const size = BLOCK_SIZE - margin * 2;

                const t = i / (snake.length - 1 || 1);  // 0 (tail) -> 1 (head)

                // Body gradient color along snake
                let r, g, b;
                if (theme === "nokia") {
                    const c1 = [34, 197, 94];   // green
                    const c2 = [45, 212, 191];  // teal
                    r = Math.floor(c1[0] + (c2[0] - c1[0]) * t);
                    g = Math.floor(c1[1] + (c2[1] - c1[1]) * t);
                    b = Math.floor(c1[2] + (c2[2] - c1[2]) * t);
                } else {
                    const c1 = [168, 85, 247];  // purple
                    const c2 = [56, 189, 248];  // cyan
                    r = Math.floor(c1[0] + (c2[0] - c1[0]) * t);
                    g = Math.floor(c1[1] + (c2[1] - c1[1]) * t);
                    b = Math.floor(c1[2] + (c2[2] - c1[2]) * t);
                }

                let outerColor = `rgb(${r},${g},${b})`;

                // Head: special brighter color
                if (i === snake.length - 1) {
                    outerColor = (theme === "nokia")
                        ? "rgb(190, 242, 100)"    // lime-ish head
                        : "rgb(244, 114, 182)";   // pink head
                }

                const radius = 8;

                // Outer rounded block (almost full cell)
                roundedRect(
                    ctx,
                    x + margin,
                    y + margin,
                    size,
                    size,
                    radius,
                    outerColor
                );

                // Inner "core" block with tiny gap (more solid)
                const innerMargin = 1;
                const innerSize = size - innerMargin * 2;
                const innerRadius = radius - 2;

                const innerColor = "rgba(15, 23, 42, 0.9)";

                roundedRect(
                    ctx,
                    x + margin + innerMargin,
                    y + margin + innerMargin,
                    innerSize,
                    innerSize,
                    innerRadius,
                    innerColor
                );
            }

            // Stop glow for eyes so they look crisp
            ctx.restore();

            // Eyes on head (use head position)
            const [hx, hy] = snake[snake.length - 1];
            const eyeRadius = 3;
            ctx.fillStyle = "#f9fafb";

            const eyeOffsetX = BLOCK_SIZE / 4;
            const eyeOffsetY = BLOCK_SIZE / 4;

            // Left eye
            ctx.beginPath();
            ctx.arc(hx + eyeOffsetX, hy + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Right eye
            ctx.beginPath();
            ctx.arc(hx + BLOCK_SIZE - eyeOffsetX, hy + eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Tiny tongue (for fun – remove if you don't like)
            ctx.strokeStyle = (theme === "nokia") ? "#f97316" : "#fb7185";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(hx + BLOCK_SIZE / 2, hy + BLOCK_SIZE / 2 + 4);
            ctx.lineTo(hx + BLOCK_SIZE / 2, hy + BLOCK_SIZE / 2 + 9);
            ctx.stroke();
        }

        function drawFood(pos, blink, isBig) {
            if (!pos || !blink) return;

            const [x, y] = pos;
            const cx = x + BLOCK_SIZE / 2;
            const cy = y + BLOCK_SIZE / 2;

            ctx.beginPath();
            if (isBig) {
                ctx.fillStyle = "yellow";
                ctx.arc(cx, cy, BIG_FOOD_RADIUS, 0, Math.PI * 2);
            } else {
                ctx.fillStyle = "red";
                ctx.arc(cx, cy, SMALL_FOOD_RADIUS, 0, Math.PI * 2);
            }
            ctx.fill();
        }

        function getTimerColor(ratio) {
            if (ratio > 0.6) return "rgb(34,197,94)";
            if (ratio > 0.3) return "rgb(250,204,21)";
            return "rgb(248,113,113)";
        }

        function updateTimerBar(ratio) {
            if (!bigFood) {
                timerBarBg.style.display = "none";
                return;
            }
            timerBarBg.style.display = "block";
            ratio = Math.max(0, Math.min(1, ratio));
            timerBarFill.style.width = (ratio * 100) + "%";
            timerBarFill.style.background = getTimerColor(ratio);
        }

        function stepLogic() {
            if (!gameStarted || gameOver || paused) return;

            const head = snake[snake.length - 1];
            let newX = head[0] + dx;
            let newY = head[1] + dy;

            // wrapping inside playable area
            if (newX < 0) newX = WIDTH - BLOCK_SIZE;
            else if (newX >= WIDTH) newX = 0;
            if (newY < TOP_PANEL_HEIGHT) newY = PLAY_BOTTOM_Y;
            else if (newY > PLAY_BOTTOM_Y) newY = TOP_PANEL_HEIGHT;

            // self collision
            if (snake.some(seg => seg[0] === newX && seg[1] === newY)) {
                gameOver = true;
                updateHighScore();
                showGameOver();
                return;
            }

            snake.push([newX, newY]);

            // small food collision
            if (smallFood && inSameCell(newX, newY, smallFood)) {
                score += LEVEL_SCORE[level];
                foodCounter += 1;
                smallFood = generateFood();
                updateHighScore();
            } else {
                snake.shift();
            }

            // spawn big food
            if (!bigFood && foodCounter >= 6) {
                bigFood = generateFood();
                bigFoodStart = performance.now() / 1000.0;
                bigFoodDuration = BIG_FOOD_DURATION[level];
                foodCounter = 0;
            }

            // big food
            if (bigFood) {
                const now = performance.now() / 1000.0;
                const elapsed = now - bigFoodStart;

                // Time over → remove big food
                if (elapsed > bigFoodDuration) {
                    bigFood = null;
                } else if (inSameCell(newX, newY, bigFood)) {
                    // ratio = 1.0 → eaten instantly, 0.0 → eaten at last moment
                    const ratio = Math.max(0, 1 - elapsed / bigFoodDuration);

                    const minScore = BIG_FOOD_MIN_SCORE[level];   // different per level
                    const maxScore = BIG_FOOD_SCORE[level];       // max possible for that level

                    // Interpolate between minScore and maxScore based on time
                    let gained = Math.round(minScore + (maxScore - minScore) * ratio);

                    // Safety: never below minScore
                    if (gained < minScore) gained = minScore;

                    score += gained;
                    updateHighScore();

                    // Grow snake by 'gained' blocks
                    const tail = snake[0];
                    for (let i = 0; i < gained; i++) {
                        snake.unshift([tail[0], tail[1]]);
                    }

                    bigFood = null;
                }
            }
        }

        function drawScene() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            const blink = Math.floor(performance.now() / 300) % 2 === 0;
            drawFood(smallFood, blink, false);

            if (bigFood) {
                const now = performance.now() / 1000.0;
                const elapsed = now - bigFoodStart;
                const ratio = Math.max(0, 1 - elapsed / bigFoodDuration);
                drawFood(bigFood, blink, true);
                updateTimerBar(ratio);
            } else {
                updateTimerBar(0);
            }

            drawSnake();
            scoreText.textContent = "Score: " + score;
        }

        function gameLoop() {
            if (!gameStarted) return;
            stepLogic();
            drawScene();
        }

        function showGameOver() {
            overlay.style.display = "flex";
            overlayTitle.innerHTML =
                `GAME OVER!<br>Your Score: ${score}<br>Snake Master Score: ${highScore}`;
            overlaySubtitle.textContent = "";
            infoText.style.display = "none";

            levelButtonsContainer.style.display = "none";
            btnPlayAgain.style.display = "inline-block";
        }

        function setDirection(dir) {
            if (!gameStarted || gameOver) return;
            if (dir === "LEFT" && dx === 0) {
                dx = -BLOCK_SIZE; dy = 0;
            } else if (dir === "RIGHT" && dx === 0) {
                dx = BLOCK_SIZE; dy = 0;
            } else if (dir === "UP" && dy === 0) {
                dx = 0; dy = -BLOCK_SIZE;
            } else if (dir === "DOWN" && dy === 0) {
                dx = 0; dy = BLOCK_SIZE;
            }
        }

        // keyboard controls
        document.addEventListener("keydown", (e) => {
            // Level select keys when level buttons shown
            if (overlay.style.display === "flex" &&
                levelButtonsContainer.style.display === "flex") {
                if (e.key === "1") resetGame("Easy");
                if (e.key === "2") resetGame("Medium");
                if (e.key === "3") resetGame("Hard");
            }

            if (!gameStarted || gameOver) return;

            if (e.key === "ArrowLeft" || e.key === "a") setDirection("LEFT");
            else if (e.key === "ArrowRight" || e.key === "d") setDirection("RIGHT");
            else if (e.key === "ArrowUp" || e.key === "w") setDirection("UP");
            else if (e.key === "ArrowDown" || e.key === "s") setDirection("DOWN");
            else if (e.key === "p" || e.key === "P") togglePause();
        });

        // Level buttons
        levelButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                const lvl = btn.getAttribute("data-level");
                resetGame(lvl);
            });
        });

        // Play Again -> back to level selection
        btnPlayAgain.addEventListener("click", () => {
            showLevelSelectScreen();
        });

        function togglePause() {
            if (!gameStarted || gameOver) return;
            paused = !paused;
            btnPause.textContent = paused ? "Resume" : "Pause";
        }

        btnPause.addEventListener("click", togglePause);
        btnExit.addEventListener("click", () => {
            showLevelSelectScreen();
        });

        // Touch controls (card on side / below)
        function attachTouch(btn, dir) {
            const handler = (e) => {
                e.preventDefault();
                setDirection(dir);
            };
            btn.addEventListener("touchstart", handler, { passive: false });
            btn.addEventListener("click", handler);
        }

        attachTouch(btnUp, "UP");
        attachTouch(btnDown, "DOWN");
        attachTouch(btnLeft, "LEFT");
        attachTouch(btnRight, "RIGHT");

        // About / Help modal logic
        function openAbout() { aboutModal.style.display = "flex"; }
        function closeAbout() { aboutModal.style.display = "none"; }
        function openHelp() { helpModal.style.display = "flex"; }
        function closeHelp() { helpModal.style.display = "none"; }

        btnAbout.addEventListener("click", openAbout);
        btnHelp.addEventListener("click", openHelp);
        aboutClose.addEventListener("click", closeAbout);
        helpClose.addEventListener("click", closeHelp);

        aboutModal.addEventListener("click", (e) => {
            if (e.target === aboutModal) closeAbout();
        });
        helpModal.addEventListener("click", (e) => {
            if (e.target === helpModal) closeHelp();
        });

        // Start on level selection
        showLevelSelectScreen();
    </script>
</body>

</html>
